// Example adapted from "Hello Triangle", available at the following URL:
// https://www.khronos.org/assets/uploads/books/openglr_es_20_programming_guide_sample.pdf

use aureum::Context;
use gl::types::*;
use std::ffi::{CStr, CString};
use std::ptr;
use stdweb::unstable::TryInto;
use stdweb::web::document;
use stdweb::web::html_element::CanvasElement;
use stdweb::Reference;
use stdweb::js;
use webgl_stdweb::WebGLRenderingContext;

struct UserData {
    program_object: GLuint,
}

// Create a shader object, load the shader source, and compile the shader.
fn load_shader(shader_src: &CStr, type_: GLenum) -> GLuint {
    // Create the shader object
    let shader = unsafe { gl::CreateShader(type_) };

    if shader == 0 {
        return 0;
    }

    // Load the shader source
    unsafe {
        gl::ShaderSource(shader, 1, [shader_src.as_ptr()].as_ptr(), ptr::null());
    }

    // Compile the shader
    unsafe {
        gl::CompileShader(shader);
    }

    // Check the compile status
    let mut compiled = 0;
    unsafe {
        gl::GetShaderiv(shader, gl::COMPILE_STATUS, &mut compiled);
    }
    if compiled == 0 {
        let mut info_len = 0;
        unsafe {
            gl::GetShaderiv(shader, gl::INFO_LOG_LENGTH, &mut info_len);
        }
        if info_len > 1 {
            let mut info_log = vec![0; info_len as usize];
            unsafe {
                gl::GetShaderInfoLog(
                    shader,
                    info_len,
                    ptr::null_mut(),
                    info_log.as_mut_ptr() as *mut _,
                );
            }
            js! {
                console.error(@{format!(
                    "Error compiling shader:\n{}\n",
                    CStr::from_bytes_with_nul(&info_log).unwrap().to_string_lossy()
                )})
            }
        }
        unsafe {
            gl::DeleteShader(shader);
        }
        return 0;
    }

    shader
}

fn init() -> Option<UserData> {
    unsafe { 
    let v_shader_str = CString::new(&include_bytes!("v.glsl")[..]).unwrap();
    let f_shader_str = CString::new(&include_bytes!("f.glsl")[..]).unwrap();

    // Load the vertex/fragment shaders
    let vertex_shader = load_shader(&v_shader_str, gl::VERTEX_SHADER);
    let fragment_shader = load_shader(&f_shader_str, gl::FRAGMENT_SHADER);

    // Create the program object
    let program_object = gl::CreateProgram();

    if program_object == 0 {
        return None;
    }

        gl::AttachShader(program_object, vertex_shader);
        gl::AttachShader(program_object, fragment_shader);

    // Bind vPosition to attribute 0
        gl::BindAttribLocation(
            program_object,
            0,
            CString::new("vPosition").unwrap().as_ptr(),
        );

    // Link the program
        gl::LinkProgram(program_object);

    // Check the link status
    let mut linked = 0;
        gl::GetProgramiv(program_object, gl::LINK_STATUS, &mut linked);
    if linked == 0 {
        let mut info_len = 0;
            gl::GetProgramiv(program_object, gl::INFO_LOG_LENGTH, &mut info_len);
        if info_len > 1 {
            let mut info_log = vec![0; info_len as usize];
                gl::GetProgramInfoLog(
                    program_object,
                    info_len,
                    ptr::null_mut(),
                    info_log.as_mut_ptr() as *mut _,
                );
            js! {
                console.error(@{format!(
                    "Error linking program:\n{}\n",
                    CStr::from_bytes_with_nul(&info_log).unwrap().to_string_lossy()
                )})
            }
        }
            gl::DeleteProgram(program_object);
        return None;
    }

        gl::ClearColor(0.0, 0.0, 0.0, 1.0);
    Some(UserData { program_object })
    }
}

const WIDTH: GLint = 800;
const HEIGHT: GLint = 600;

fn draw(user_data: &UserData) {
    unsafe { 
    #[rustfmt::skip]
    let vertices = [
        0.0, 0.5, 0.0,
        -0.5, -0.5, 0.0,
        0.5, -0.5, 0.0
    ];

    // Set the viewport
        gl::Viewport(0, 0, WIDTH, HEIGHT);

    // Clear the color buffer
        gl::Clear(gl::COLOR_BUFFER_BIT);

    // Use the program object
        gl::UseProgram(user_data.program_object);

    // Load the vertex data
        gl::VertexAttribPointer(0, 3, gl::FLOAT, gl::FALSE, 0, vertices.as_ptr() as *const _);
        gl::EnableVertexAttribArray(0);

        gl::DrawArrays(gl::TRIANGLES, 0, 3);
    }
}

fn main() {
    gl::load_with(aureum::get_proc_address);

    let canvas: CanvasElement = document()
        .create_element("canvas")
        .unwrap()
        .try_into()
        .unwrap();
    canvas.set_width(WIDTH as u32);
    canvas.set_height(HEIGHT as u32);

    let webgl: WebGLRenderingContext = canvas.get_context().unwrap();
    let context = Context::new(Reference::from(webgl).try_into().unwrap());
    aureum::make_current(Some(context.clone()));

    let user_data = init().unwrap();

    loop {
        draw(&user_data);
    }
}
